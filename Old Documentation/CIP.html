<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>CIP</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_CIP.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption empty">&nbsp;</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr></table><p class="caption">CIP</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Data Structure Definitions</a></li><li><a href="#g:2">Creating Convex Integral Paths and Convex Generators</a></li><li><a href="#g:3">Basic Properties of Convex Generators</a></li><li><a href="#g:4">Less Than and Theorem 1.19</a><ul><li><a href="#g:5">Condition Checks</a></li><li><a href="#g:6">Computating Convex Generators, Factorizations, and Decompositions</a></li></ul></li></ul></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">type</span> <a href="#t:Vertex">Vertex</a> = (Int, Int)</li><li class="src short"><span class="keyword">type</span> <a href="#t:Edge">Edge</a> = (Int, Int)</li><li class="src short"><span class="keyword">data</span> <a href="#t:Label">Label</a><ul class="subs"><li>= <a href="#v:E">E</a></li><li>| <a href="#v:H">H</a></li></ul></li><li class="src short"><span class="keyword">data</span> <a href="#t:CIP">CIP</a></li><li class="src short"><span class="keyword">data</span> <a href="#t:CGen">CGen</a></li><li class="src short"><span class="keyword">data</span> <a href="#t:CTD">CTD</a><ul class="subs"><li>= <a href="#v:Ellipsoid">Ellipsoid</a> Double Double</li><li>| <a href="#v:Polydisk">Polydisk</a> Double Double</li><li>| <a href="#v:CTD">CTD</a> { <ul class="subs"><li><a href="#v:getBoundary">getBoundary</a> :: <a href="CIP.html#t:CIP">CIP</a></li></ul> }</li></ul></li><li class="src short"><span class="keyword">type</span> <a href="#t:Decomposition">Decomposition</a> = ([<a href="CIP.html#t:CGen">CGen</a>], [<a href="CIP.html#t:CGen">CGen</a>])</li><li class="src short"><a href="#v:pathFromVerts">pathFromVerts</a> :: [<a href="CIP.html#t:Vertex">Vertex</a>] -&gt; <a href="CIP.html#t:CIP">CIP</a></li><li class="src short"><a href="#v:pathFromEdges">pathFromEdges</a> :: [<a href="CIP.html#t:Edge">Edge</a>] -&gt; <a href="CIP.html#t:CIP">CIP</a></li><li class="src short"><a href="#v:makeCGen">makeCGen</a> :: <a href="CIP.html#t:CIP">CIP</a> -&gt; [<a href="CIP.html#t:Label">Label</a>] -&gt; <a href="CIP.html#t:CGen">CGen</a></li><li class="src short"><a href="#v:makeAllEGen">makeAllEGen</a> :: <a href="CIP.html#t:CIP">CIP</a> -&gt; <a href="CIP.html#t:CGen">CGen</a></li><li class="src short"><a href="#v:readCGen">readCGen</a> :: String -&gt; <a href="CIP.html#t:CGen">CGen</a></li><li class="src short"><a href="#v:getX">getX</a> :: Num a =&gt; <a href="CIP.html#t:CGen">CGen</a> -&gt; a</li><li class="src short"><a href="#v:getY">getY</a> :: Num a =&gt; <a href="CIP.html#t:CGen">CGen</a> -&gt; a</li><li class="src short"><a href="#v:getH">getH</a> :: Num a =&gt; <a href="CIP.html#t:CGen">CGen</a> -&gt; a</li><li class="src short"><a href="#v:getM">getM</a> :: Num a =&gt; <a href="CIP.html#t:CGen">CGen</a> -&gt; a</li><li class="src short"><a href="#v:getL">getL</a> :: Num a =&gt; <a href="CIP.html#t:CGen">CGen</a> -&gt; a</li><li class="src short"><a href="#v:index">index</a> :: Num a =&gt; <a href="CIP.html#t:CGen">CGen</a> -&gt; a</li><li class="src short"><a href="#v:action">action</a> :: <a href="CIP.html#t:CTD">CTD</a> -&gt; <a href="CIP.html#t:CGen">CGen</a> -&gt; Double</li><li class="src short"><a href="#v:isLessThan">isLessThan</a> :: <a href="CIP.html#t:CTD">CTD</a> -&gt; <a href="CIP.html#t:CTD">CTD</a> -&gt; <a href="CIP.html#t:CGen">CGen</a> -&gt; <a href="CIP.html#t:CGen">CGen</a> -&gt; Bool</li><li class="src short"><a href="#v:noSharedEOrbits">noSharedEOrbits</a> :: <a href="CIP.html#t:CGen">CGen</a> -&gt; <a href="CIP.html#t:CGen">CGen</a> -&gt; Bool</li><li class="src short"><a href="#v:bullet2">bullet2</a> :: <a href="CIP.html#t:Decomposition">Decomposition</a> -&gt; Bool</li><li class="src short"><a href="#v:bullet3">bullet3</a> :: <a href="CIP.html#t:Decomposition">Decomposition</a> -&gt; Bool</li><li class="src short"><a href="#v:validDecomposition">validDecomposition</a> :: <a href="CIP.html#t:CTD">CTD</a> -&gt; <a href="CIP.html#t:CTD">CTD</a> -&gt; <a href="CIP.html#t:Decomposition">Decomposition</a> -&gt; Bool</li><li class="src short"><a href="#v:generateLessThan">generateLessThan</a> :: <a href="CIP.html#t:CTD">CTD</a> -&gt; <a href="CIP.html#t:CTD">CTD</a> -&gt; <a href="CIP.html#t:CGen">CGen</a> -&gt; [<a href="CIP.html#t:CGen">CGen</a>]</li><li class="src short"><a href="#v:factorizations">factorizations</a> :: <a href="CIP.html#t:CGen">CGen</a> -&gt; [[<a href="CIP.html#t:CGen">CGen</a>]]</li><li class="src short"><a href="#v:decompositions">decompositions</a> :: <a href="CIP.html#t:CTD">CTD</a> -&gt; <a href="CIP.html#t:CTD">CTD</a> -&gt; <a href="CIP.html#t:CGen">CGen</a> -&gt; [<a href="CIP.html#t:Decomposition">Decomposition</a>]</li><li class="src short"><a href="#v:thm119">thm119</a> :: <a href="CIP.html#t:CTD">CTD</a> -&gt; <a href="CIP.html#t:CTD">CTD</a> -&gt; <a href="CIP.html#t:CGen">CGen</a> -&gt; Maybe <a href="CIP.html#t:Decomposition">Decomposition</a></li><li class="src short"><a href="#v:thm119-39-">thm119'</a> :: <a href="CIP.html#t:CTD">CTD</a> -&gt; <a href="CIP.html#t:CTD">CTD</a> -&gt; <a href="CIP.html#t:CGen">CGen</a> -&gt; [<a href="CIP.html#t:Decomposition">Decomposition</a>]</li></ul></div><div id="interface"><h1>Documentation</h1><div class="doc"><p>A quick note about the notation in this document: for the functions below, you will see something
 that looks like</p><pre>action :: CTD -&gt; CGen -&gt; Double</pre><p>The &quot;::&quot; means &quot;has type&quot;; what follows is the type signature of the function, i.e. the
 types of the arguments it takes and the type of its return values. These are all in order and
 separated by arrows. In the above example, then, we see that the action function
 takes two arguments (the first of type CTD and the second of type CGen) and returns a Double
 value (i.e. a decimal number).</p><p>Once you get used to their format, type signatures are very useful for showing you how to use a function.
 The only thing they don't tell you is which argument does what (which can get confusing if you have two
 arguments of the same type -- but that's what this documentation is for!) If you ever forget the type
 signature of a function while working, rather than checking back in the documentation, you can type
 &quot;:t &lt;functionname&gt;&quot; into GHCi, and it will print out the type signature of the function &lt;functionname&gt;.</p></div><h1 id="g:1">Data Structure Definitions</h1><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Vertex" class="def">Vertex</a> = (Int, Int)</p><div class="doc"><p>A Vertex is meant to represent a lattice point. These will be, for instance, vertices
 of our convex integral paths as well as the points that we count up in order to compute
 L for a convex generator. A Vertex is made by typing a 2-tuple of integers: for instance,</p><pre>let vert = (4,5)</pre></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Edge" class="def">Edge</a> = (Int, Int)</p><div class="doc"><p>An Edge represents the displacement vector corresponding to an edge of a convex integral
 path. Being a 2-tuple of integers, an Edge is syntactically identical to a Vertex; Haskell
 cannot tell the difference between the two. Their names are purely for readability of function
 names and of code.</p></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:Label" class="def">Label</a></p><div class="doc"><p>Labels represent the letters attached to edges of a convex generator. As such, there are two
 types of Labels: E and H. Note that these are not Strings but data types in their own right;
 we don't type &quot;E&quot; but instead simply E. Also, due to Haskell's naming conventions, the letters
 must be capitalized.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:E" class="def">E</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:H" class="def">H</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:Label" class="caption collapser" onclick="toggleSection('i:Label')">Instances</p><div id="section.i:Label" class="show"><table><tr><td class="src">Eq <a href="CIP.html#t:Label">Label</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">Read <a href="CIP.html#t:Label">Label</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">Show <a href="CIP.html#t:Label">Label</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:CIP" class="def">CIP</a></p><div class="doc"><p>CIP stands for &quot;convex integral path.&quot; The data that a CIP holds is simply a list of Vertices,
 which correspond to every lattice point along the convex integral path (NOT just the ones between
 two edges of different slopes). That said, you cannot substitute a list of Vertices for a CIP;
 they are two different data structures.</p><p>The function getVertices takes a CIP and returns the list of vertices that is stored in it:
 for instance,</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>getVertices (pathFromVerts [(0,2),(2,2),(2,0)])
</code></strong>[(0,2),(1,2),(2,2),(2,1),(2,0)]
</pre><p>(See below for information about how <code><a href="CIP.html#v:pathFromVerts">pathFromVerts</a></code> works.)</p></div><div class="subs instances"><p id="control.i:CIP" class="caption collapser" onclick="toggleSection('i:CIP')">Instances</p><div id="section.i:CIP" class="show"><table><tr><td class="src">Eq <a href="CIP.html#t:CIP">CIP</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">Show <a href="CIP.html#t:CIP">CIP</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">Generic <a href="CIP.html#t:CIP">CIP</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">NFData <a href="CIP.html#t:CIP">CIP</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> Rep <a href="CIP.html#t:CIP">CIP</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:CGen" class="def">CGen</a></p><div class="doc"><p>A CGen represents a convex generator. It contains a convex integral path and a list of labels.
 The Labels correspond to the labels on the edges of the convex generator, from left to right.</p><p>The functions getPath and getLabels both take a CGen as an argument and return the CIP and the
 list of Labels, respectively, that are held in the CGen.</p></div><div class="subs instances"><p id="control.i:CGen" class="caption collapser" onclick="toggleSection('i:CGen')">Instances</p><div id="section.i:CGen" class="show"><table><tr><td class="src">Eq <a href="CIP.html#t:CGen">CGen</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">Ord <a href="CIP.html#t:CGen">CGen</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">Show <a href="CIP.html#t:CGen">CGen</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">Generic <a href="CIP.html#t:CGen">CGen</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">Monoid <a href="CIP.html#t:CGen">CGen</a></td><td class="doc"><p>Here we see that CGen is a Monoid. This means precisely what it would mathematically.
 The function representing the monoid operation is called mappend. As you might expect,
 it takes 2 CGens as arguments and returns the CGen formed by concatenating the edges of the
 input CGens. Since we usually write such a binary operation infixed (like we would with
 + or *), it is standard to call mappend in this format as well: for example,</p><pre>cg1 `mappend` cg2</pre><p>Note that mappend is surrounded with backticks (the thing on the tilde key), NOT
 single quotation marks.</p></td></tr><tr><td class="src">NFData <a href="CIP.html#t:CGen">CGen</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">type</span> Rep <a href="CIP.html#t:CGen">CGen</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:CTD" class="def">CTD</a></p><div class="doc"><p>CTD stands for &quot;convex toric domain.&quot; Since convex toric domains are precisely the areas in the
 first quadrant bounded by a CIP, the only data CTDs hold are the CIPs that make up their boundary.
 However, for ease of use and internal efficiency, there are two more specific types of CTDs.
 For any floats (i.e. deecimal numbers) a and b, &quot;Ellipsoid a b&quot; represents the ellipsoid
 E(a,b), and &quot;Polydisk a b&quot; represents the polydisk P(a,b).</p><p>Note: the following syntax is required to make a CTD that is not an Ellipsoid or a Polydisk:</p><pre>let myctd = CTD { getBoundary = &lt;boundary&gt; }</pre><p>where &lt;boundary&gt; is a CIP. Moreover, getBoundary is a function that take a CTD and returns
 the CIP that is its boundary. However, getBoundary only works on generic CTDs, NOT on 
 Ellipsoids or Polydisks.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Ellipsoid" class="def">Ellipsoid</a> Double Double</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:Polydisk" class="def">Polydisk</a> Double Double</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:CTD" class="def">CTD</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:getBoundary" class="def">getBoundary</a> :: <a href="CIP.html#t:CIP">CIP</a></dt><dd class="doc empty">&nbsp;</dd></dl><div class="clear"></div></div></td></tr></table></div><div class="subs instances"><p id="control.i:CTD" class="caption collapser" onclick="toggleSection('i:CTD')">Instances</p><div id="section.i:CTD" class="show"><table><tr><td class="src">Eq <a href="CIP.html#t:CTD">CTD</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">Show <a href="CIP.html#t:CTD">CTD</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Decomposition" class="def">Decomposition</a> = ([<a href="CIP.html#t:CGen">CGen</a>], [<a href="CIP.html#t:CGen">CGen</a>])</p><div class="doc"><p>A Decomposition represents all the data that is produced from applying Theorem 1.19.
 Factorizations are represented as lists of convex generators (where each element of the
 list is a factor); decompositions, therefore, are 2-tuples of factorizations. The first element
 in the tuple represents the factorization of lambda' (i.e. the convex generator that we
 apply Theorem 1.19 to); the second element represents the factorization of lambda.</p></div></div><h1 id="g:2">Creating Convex Integral Paths and Convex Generators</h1><div class="top"><p class="src"><a name="v:pathFromVerts" class="def">pathFromVerts</a> :: [<a href="CIP.html#t:Vertex">Vertex</a>] -&gt; <a href="CIP.html#t:CIP">CIP</a></p><div class="doc"><p>Given a list of vertices, this function will create the convex integral path formed by
 connecting each of the vertices to its successor in the list with a straight line. Note
 that the vertices must create a valid convex integral path: that is, the first vertex must be
 on the postive y-axis, the last vertex must be on the positive x-axis, the x-values of the
 vertices must be increasing, and convexity must be satisfied.</p></div></div><div class="top"><p class="src"><a name="v:pathFromEdges" class="def">pathFromEdges</a> :: [<a href="CIP.html#t:Edge">Edge</a>] -&gt; <a href="CIP.html#t:CIP">CIP</a></p><div class="doc"><p>Given a list of edges, this function will create the convex integral path formed by
 connecting each of these edges in the order they are given. Note that the edges must form a
 valid convex integral path: that is, they must have non-negative x-values and non-positive
 y-values, and the slopes must be descending.</p></div></div><div class="top"><p class="src"><a name="v:makeCGen" class="def">makeCGen</a> :: <a href="CIP.html#t:CIP">CIP</a> -&gt; [<a href="CIP.html#t:Label">Label</a>] -&gt; <a href="CIP.html#t:CGen">CGen</a></p><div class="doc"><p>Given a CIP and a list of Labels, this function creates the convex generator formed by
 labeling the first edge (from the left) of the CIP with the first label in the list,
 the second edge with the second label, and so on. There must be precisely as many labels
 as there are edges of the CIP, and recall that horizontal and vertical edges cannot be
 labelled H.</p></div></div><div class="top"><p class="src"><a name="v:makeAllEGen" class="def">makeAllEGen</a> :: <a href="CIP.html#t:CIP">CIP</a> -&gt; <a href="CIP.html#t:CGen">CGen</a></p><div class="doc"><p>A convenience function which takes a CIP and creates the convex generator formed by
 labelling all the edges E.</p></div></div><div class="top"><p class="src"><a name="v:readCGen" class="def">readCGen</a> :: String -&gt; <a href="CIP.html#t:CGen">CGen</a></p><div class="doc"><p>This function takes in a String representation of a convex generator and creates a convex
 generator out of it. The schema for String representations is very similar to Michael Hutchings'
 notation, but since subscripts and superscripts are infeasible on the command line, we write powers
 as coefficients and write the edge vectors after the labels. For instance: &quot;3E(1,-1)&quot; represents
 the convex generator with one edge going from (0,3) to (3,0) labelled &quot;E.&quot; Note two big differences
 from Hutchings' notation: first, that the y-value of edges does retain its negative sign, i.e. we
 have 3E(1,-1) and NOT 3E(1,1); and secondly, that the label letters are capitalized.</p></div></div><h1 id="g:3">Basic Properties of Convex Generators</h1><div class="top"><p class="src"><a name="v:getX" class="def">getX</a> :: Num a =&gt; <a href="CIP.html#t:CGen">CGen</a> -&gt; a</p><div class="doc"><p>Computes x() for a given convex generator (i.e. the x-value of the final vertex of the generator).</p></div></div><div class="top"><p class="src"><a name="v:getY" class="def">getY</a> :: Num a =&gt; <a href="CIP.html#t:CGen">CGen</a> -&gt; a</p><div class="doc"><p>Computes y() for a given convex generator (i.e. the y-value of the first vertex of the generator).</p></div></div><div class="top"><p class="src"><a name="v:getH" class="def">getH</a> :: Num a =&gt; <a href="CIP.html#t:CGen">CGen</a> -&gt; a</p><div class="doc"><p>Computes h() for a given convex generator (i.e. the number of edges labelled H).</p></div></div><div class="top"><p class="src"><a name="v:getM" class="def">getM</a> :: Num a =&gt; <a href="CIP.html#t:CGen">CGen</a> -&gt; a</p><div class="doc"><p>Computes m() for a given convex generator (i.e. the total multiplicity of all edges of
 the generator, which is equal to the number of lattice points on the path of the generator minus one).</p></div></div><div class="top"><p class="src"><a name="v:getL" class="def">getL</a> :: Num a =&gt; <a href="CIP.html#t:CGen">CGen</a> -&gt; a</p><div class="doc"><p>Computes L() for a given convex generator (i.e. the total number of lattice points enclosed
 by the generator, including points on the generator and on the positive axes).</p></div></div><div class="top"><p class="src"><a name="v:index" class="def">index</a> :: Num a =&gt; <a href="CIP.html#t:CGen">CGen</a> -&gt; a</p><div class="doc"><p>Computes the index I() of the generator: for a generator cg,</p><pre>index cg = 2*(getL cg - 1) - getH cg</pre></div></div><div class="top"><p class="src"><a name="v:action" class="def">action</a> :: <a href="CIP.html#t:CTD">CTD</a> -&gt; <a href="CIP.html#t:CGen">CGen</a> -&gt; Double</p><div class="doc"><p>Computes the symplectic action of a given convex generator with respect to a given convex toric domain.
 Actions with respect to Ellipsoids and Polydisks are computed using the formulas specific to those convex
 toric domains (see &quot;Beyond ECH Capacities,&quot; Example 1.14); general domains are computed using the general
 action formula (see &quot;Beyond ECH Capacities,&quot; Definition 1.13).</p></div></div><h1 id="g:4">Less Than and Theorem 1.19</h1><h2 id="g:5">Condition Checks</h2><div class="top"><p class="src"><a name="v:isLessThan" class="def">isLessThan</a> :: <a href="CIP.html#t:CTD">CTD</a> -&gt; <a href="CIP.html#t:CTD">CTD</a> -&gt; <a href="CIP.html#t:CGen">CGen</a> -&gt; <a href="CIP.html#t:CGen">CGen</a> -&gt; Bool</p><div class="doc"><p>Given two CTDs, ctd and ctd', and two CGens, cg and cg', isLessThan ctd ctd' cg cg' returns
 True if cg is less than or equal to cg' with respect to ctd and ctd' (see &quot;Beyond ECH Capacities&quot;
 Definition 1.17) and False otherwise. Note that the first CTD supplied goes with the first 
 CGen supplied, i.e. for the action condition, isLessThan ctd ctd' cg cg' will check that</p><pre>action ctd cg &lt;= action ctd' cg'</pre></div></div><div class="top"><p class="src"><a name="v:noSharedEOrbits" class="def">noSharedEOrbits</a> :: <a href="CIP.html#t:CGen">CGen</a> -&gt; <a href="CIP.html#t:CGen">CGen</a> -&gt; Bool</p><div class="doc"><p>Given two CGens, this function returns True if the generators share no elliptical orbits
 and False otherwise.</p></div></div><div class="top"><p class="src"><a name="v:bullet2" class="def">bullet2</a> :: <a href="CIP.html#t:Decomposition">Decomposition</a> -&gt; Bool</p><div class="doc"><p>Checks if a given Decomposition satisfies the second bullet point of Theorem 1.19: that is,
 for any pair of indices i and j in the factorizations of the Decomposition, either
 the factors at index i and j are equal in each of the factorizations, or the factors
 at index i and j in the second factorization (correspondig to lambda, not lambda') share no
 elliptical orbit.</p></div></div><div class="top"><p class="src"><a name="v:bullet3" class="def">bullet3</a> :: <a href="CIP.html#t:Decomposition">Decomposition</a> -&gt; Bool</p><div class="doc"><p>Checks if a given Decomposition satisfies the third bullet point of Theorem 1.19: that is,
 for any subset of indices in the factorizations, if we take the product of all the factors at
 those indices in the lambda factorization and the product of all the factors at those indices
 in the lambda' factorization, the two resulting convex generators will have equal indices (I() values).</p></div></div><div class="top"><p class="src"><a name="v:validDecomposition" class="def">validDecomposition</a> :: <a href="CIP.html#t:CTD">CTD</a> -&gt; <a href="CIP.html#t:CTD">CTD</a> -&gt; <a href="CIP.html#t:Decomposition">Decomposition</a> -&gt; Bool</p><div class="doc"><p>Given two CTDs and a Decomposition, checks if the Decomposition satisfies all the conditions
 of Theorem 1.19. This is equivalent to running the functions bullet2 and bullet3 on the Decomposition,
 and then going through each of the factorizations and checking that the factors in the right
 (lambda) factorizations are less than the corresponding factors in the left (lambda') factorization.</p></div></div><h2 id="g:6">Computating Convex Generators, Factorizations, and Decompositions</h2><div class="top"><p class="src"><a name="v:generateLessThan" class="def">generateLessThan</a> :: <a href="CIP.html#t:CTD">CTD</a> -&gt; <a href="CIP.html#t:CTD">CTD</a> -&gt; <a href="CIP.html#t:CGen">CGen</a> -&gt; [<a href="CIP.html#t:CGen">CGen</a>]</p><div class="doc"><p>This function computes a list of all convex generators less than or equal to a given 
 CGen with respect to two given CTDs. If you just want to know if one CGen is less than
 or equal to another, use <code><a href="CIP.html#v:isLessThan">isLessThan</a></code> above.</p></div></div><div class="top"><p class="src"><a name="v:factorizations" class="def">factorizations</a> :: <a href="CIP.html#t:CGen">CGen</a> -&gt; [[<a href="CIP.html#t:CGen">CGen</a>]]</p><div class="doc"><p>Computes all factorizations of a given CGen.</p></div></div><div class="top"><p class="src"><a name="v:decompositions" class="def">decompositions</a> :: <a href="CIP.html#t:CTD">CTD</a> -&gt; <a href="CIP.html#t:CTD">CTD</a> -&gt; <a href="CIP.html#t:CGen">CGen</a> -&gt; [<a href="CIP.html#t:Decomposition">Decomposition</a>]</p><div class="doc"><p>Computes all the decompositions of a given CGen which satisfy the first bullet point of
 Theorem 1.19.</p></div></div><div class="top"><p class="src"><a name="v:thm119" class="def">thm119</a> :: <a href="CIP.html#t:CTD">CTD</a> -&gt; <a href="CIP.html#t:CTD">CTD</a> -&gt; <a href="CIP.html#t:CGen">CGen</a> -&gt; Maybe <a href="CIP.html#t:Decomposition">Decomposition</a></p><div class="doc"><p>Given two CTDs and a CGen, this function attempts to apply Theorem 1.19 to the CGen
 by finding a Decomposition that satisfies the conditions of the Theorem. If no valid 
 Decomposition exists, then the value Nothing is returned; otherwise, the value Just
 decomp is returned, where decomp is a valid Decomposition. </p><p>Note: in order to extract the decomposition from this Just decomp format, use the
 function maybe: for instance, if ctd1 and ctd2 are CTDs and cg is a CGen:</p><pre>let result = thm119 ctd1 ctd2 cg
let extracted = maybe ([],[]) id result</pre><p>The above will set the value of extracted to ([],[]) (i.e. an empty Decomposition) if
 no valid Decomposition exists or to the value of the Decomposition itself (with no &quot;Just&quot;
 attached) if a valid Decomposition does exist.</p></div></div><div class="top"><p class="src"><a name="v:thm119-39-" class="def">thm119'</a> :: <a href="CIP.html#t:CTD">CTD</a> -&gt; <a href="CIP.html#t:CTD">CTD</a> -&gt; <a href="CIP.html#t:CGen">CGen</a> -&gt; [<a href="CIP.html#t:Decomposition">Decomposition</a>]</p><div class="doc"><p>This function is very similar to thm119, except that it returns a list of all valid Decompositions.
 if no valid Decomposition exists, then the empty list, [], will be returned.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.14.3</p></div></body></html>