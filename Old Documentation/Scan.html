<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Scan</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Scan.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption empty">&nbsp;</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr></table><p class="caption">Scan</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Creating Scanners</a></li><li><a href="#g:2">Modifying Output</a></li><li><a href="#g:3">Scanning</a></li></ul></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short">module <a href="CIP.html">CIP</a></li><li class="src short"><span class="keyword">data</span> <a href="#t:ScanRange">ScanRange</a> t1 t2</li><li class="src short"><span class="keyword">data</span> <a href="#t:Scanner">Scanner</a> t1 t2</li><li class="src short"><a href="#v:normalOver">normalOver</a> :: (RealFrac t1, Read t1, Show t1, RealFrac t2, Read t2, Show t2) =&gt; (t1 -&gt; <a href="CIP.html#t:CTD">CTD</a>) -&gt; (t2 -&gt; <a href="CIP.html#t:CTD">CTD</a>) -&gt; [<a href="CIP.html#t:CGen">CGen</a>] -&gt; [t1] -&gt; [[t2]] -&gt; <a href="Scan.html#t:Scanner">Scanner</a> t1 t2</li><li class="src short"><a href="#v:rangeOver">rangeOver</a> :: (RealFrac t1, Read t1, Show t1, RealFrac t2, Read t2, Show t2) =&gt; (t1 -&gt; <a href="CIP.html#t:CTD">CTD</a>) -&gt; (t2 -&gt; <a href="CIP.html#t:CTD">CTD</a>) -&gt; [<a href="CIP.html#t:CGen">CGen</a>] -&gt; (t1, t1, t1) -&gt; (t1 -&gt; t2) -&gt; (t2, t2, t2) -&gt; <a href="Scan.html#t:Scanner">Scanner</a> t1 t2</li><li class="src short"><a href="#v:quickOver">quickOver</a> :: (RealFrac t1, Read t1, Show t1, RealFrac t2, Read t2, Show t2) =&gt; (t1 -&gt; <a href="CIP.html#t:CTD">CTD</a>) -&gt; (t2 -&gt; <a href="CIP.html#t:CTD">CTD</a>) -&gt; [<a href="CIP.html#t:CGen">CGen</a>] -&gt; (t1, t1, t1) -&gt; (t1 -&gt; t2) -&gt; (t2, t2, t2) -&gt; <a href="Scan.html#t:Scanner">Scanner</a> t1 t2</li><li class="src short"><a href="#v:useOffsets">useOffsets</a> ::  <a href="Scan.html#t:Scanner">Scanner</a> t1 t2 -&gt; <a href="Scan.html#t:Scanner">Scanner</a> t1 t2</li><li class="src short"><a href="#v:noOffsets">noOffsets</a> ::  <a href="Scan.html#t:Scanner">Scanner</a> t1 t2 -&gt; <a href="Scan.html#t:Scanner">Scanner</a> t1 t2</li><li class="src short"><a href="#v:tabulate">tabulate</a> ::  <a href="Scan.html#t:Scanner">Scanner</a> t1 t2 -&gt; <a href="Scan.html#t:Scanner">Scanner</a> t1 t2</li><li class="src short"><a href="#v:tabulateWith">tabulateWith</a> ::  (String, String, String, String) -&gt; (Int, Int, Int) -&gt; <a href="Scan.html#t:Scanner">Scanner</a> t1 t2 -&gt; <a href="Scan.html#t:Scanner">Scanner</a> t1 t2</li><li class="src short"><a href="#v:plainText">plainText</a> ::  <a href="Scan.html#t:Scanner">Scanner</a> t1 t2 -&gt; <a href="Scan.html#t:Scanner">Scanner</a> t1 t2</li><li class="src short"><a href="#v:toStd">toStd</a> ::  <a href="Scan.html#t:Scanner">Scanner</a> t1 t2 -&gt; <a href="Scan.html#t:Scanner">Scanner</a> t1 t2</li><li class="src short"><a href="#v:toFile">toFile</a> ::  String -&gt; Bool -&gt; <a href="Scan.html#t:Scanner">Scanner</a> t1 t2 -&gt; <a href="Scan.html#t:Scanner">Scanner</a> t1 t2</li><li class="src short"><a href="#v:toFileAndStd">toFileAndStd</a> ::  String -&gt; Bool -&gt; <a href="Scan.html#t:Scanner">Scanner</a> t1 t2 -&gt; <a href="Scan.html#t:Scanner">Scanner</a> t1 t2</li><li class="src short"><a href="#v:scan">scan</a> :: (RealFrac t1, Read t1, Show t1, RealFrac t2, Read t2, Show t2) =&gt; <a href="Scan.html#t:Scanner">Scanner</a> t1 t2 -&gt; IO ()</li></ul></div><div id="interface"><h1>Documentation</h1><div class="doc"><p>This module exists provides the ability to scan the results of applying Hutchings' Theorem 1.19
 to many different convex toric domains and many different convex generators. The results of scans
 can be output in many different formats and saved to a file if desired. The expected workflow is:
 first, create a Scanner (see 'Creating Scanners' below); then, modify the output settings (see
 'Modifying Output' below); and finally, use the <code><a href="Scan.html#v:scan">scan</a></code> function.</p><p>Currently, the only types of allowed scans are on one variable in the first CTD and one variable in
 the second. For instance, in the problem of embedding P(a,1) into E(c,c), one could scan the results
 of Theorem 1.19 for many different a and c values. This module also re-exports the CIP module, so that
 you don't have to load both of them.</p><p>Since it is hard to explain how to use the Scanner creation functions without getting into some details
 about Haskell, I have included an example usage here. My hope is that adapting this example will allow you
 to use the other available functions even without understanding all of the Haskell. Of course, if you have
 any questions, please don't hesitate to email me!</p><p>Let's use the P(a,1) into E(c,c) problem for our example. Imagine we want to check whether E(i,-i), for
 i from 1 to 10, will allow us to extend Michael Hutchings' result on this problem (Theorem 1.4 in
 &quot;Beyond ECH Capacities&quot;). First, we create a list of all our CGens:</p><pre>let cgs = map (\i -&gt; makeAllEGen (pathFromEdges [(i,-i)])) [1..10]</pre><p>(Don't worry if you aren't clear on how this works -- you can simply copy this line as I've written it,
 and if you want to change the range of the i's to, say, everything from x to y inclusive, replace the
 [1..10] on the end with [x..y].) Now, we need to create a Scanner. We will scan over all a values from
 2.41 to 2.70, inclusive, in increments of 0.01. For each a, we will try every c value from 2+a/2-0.05 up
 to 2+a/2 in increments of 0.01. The syntax for this is:</p><pre>let s = rangeOver (\a -&gt; Polydisk a 1) (\c -&gt; Ellipsoid c c) cgs (2.41,2.70,0.01) (\a -&gt; 2+a/2) (-0.05,0,0.01)</pre><p>Here, we use several so-called &quot;lambda functions&quot;. For instance, &quot;(\a -&gt; Polydisk a 1)&quot; represents
 a function that takes in some value of a and returns the CTD given by Polydisk a 1. Now that we have our
 Scanner, we can call several functions to modify its output:</p><pre>let s' = (tabulate . noOffsets . toStd) Scanner</pre><p>(The dots here are the Haskell syntax for function composition.) Now, we are ready to run our scan:</p><pre>scan s'</pre></div><div class="top"><p class="src">module <a href="CIP.html">CIP</a></p></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:ScanRange" class="def">ScanRange</a> t1 t2</p></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:Scanner" class="def">Scanner</a> t1 t2</p></div><h1 id="g:1">Creating Scanners</h1><div class="top"><p class="src"><a name="v:normalOver" class="def">normalOver</a> :: (RealFrac t1, Read t1, Show t1, RealFrac t2, Read t2, Show t2) =&gt; (t1 -&gt; <a href="CIP.html#t:CTD">CTD</a>) -&gt; (t2 -&gt; <a href="CIP.html#t:CTD">CTD</a>) -&gt; [<a href="CIP.html#t:CGen">CGen</a>] -&gt; [t1] -&gt; [[t2]] -&gt; <a href="Scan.html#t:Scanner">Scanner</a> t1 t2</p><div class="doc"><p>Creates a Scanner for a normal scan. The first two arguments are functions that generate CTDs; the third
 is a list of the CGens to scan with. The fourth and fifth arguments specify all the values that will be put
 into the first and second arguments, respectively, to yield CTDs to scan over. For instance, in the
 P(a,1) into B(c,c) example, the fourth argument is the list of all <em>a</em> values, and the fifth argument is
 a list containing a list of <em>c</em> values to try for each a value. For a given <em>a</em> value, the scan will try each
 <em>c</em> value in the corresponding list; as soon as it finds a valid Decomposition, it will move on to the next
 <em>a</em> value. As soon as some a value has a valid Decomposition for its very first <em>c</em> value, the scan will end.
 Note that this behavior makes sense in practice: for instance, in the P(a,1) into B(c,c) problem,
 creating an increasing list of <em>c</em> values for each <em>a</em> value ensures that if <em>(a,c)</em>
 yields a valid decomposition, then that same Decomposition will be valid for every <em>c</em> value after <em>c</em>
 in the list.</p></div></div><div class="top"><p class="src"><a name="v:rangeOver" class="def">rangeOver</a> :: (RealFrac t1, Read t1, Show t1, RealFrac t2, Read t2, Show t2) =&gt; (t1 -&gt; <a href="CIP.html#t:CTD">CTD</a>) -&gt; (t2 -&gt; <a href="CIP.html#t:CTD">CTD</a>) -&gt; [<a href="CIP.html#t:CGen">CGen</a>] -&gt; (t1, t1, t1) -&gt; (t1 -&gt; t2) -&gt; (t2, t2, t2) -&gt; <a href="Scan.html#t:Scanner">Scanner</a> t1 t2</p><div class="doc"><p>Creates a Scanner for a range scan. The only difference between this and a normal scan 
 (see <code><a href="Scan.html#v:normalOver">normalOver</a></code> above) is that, rather than specifying each CTD explicitly, the arguments given are a 
 range of values to try. In the P(a,1) into B(c,c) example, we can make the third argument (2.41,2.70,0.01)
 to scan every <em>a</em> value from 2.41 to 2.70, inclusive, in increments of 0.01. If we want to try, for each <em>a</em>,
 every <em>c</em> value from 2+a/2-0.05 to 2+a/2 in increments of 0.01, we make the fourth argument
 (\a -&gt; 2+a/2) and the fifth argument (-0.05,0,0.01).</p></div></div><div class="top"><p class="src"><a name="v:quickOver" class="def">quickOver</a> :: (RealFrac t1, Read t1, Show t1, RealFrac t2, Read t2, Show t2) =&gt; (t1 -&gt; <a href="CIP.html#t:CTD">CTD</a>) -&gt; (t2 -&gt; <a href="CIP.html#t:CTD">CTD</a>) -&gt; [<a href="CIP.html#t:CGen">CGen</a>] -&gt; (t1, t1, t1) -&gt; (t1 -&gt; t2) -&gt; (t2, t2, t2) -&gt; <a href="Scan.html#t:Scanner">Scanner</a> t1 t2</p><div class="doc"><p>Creates a Scanner for a quick scan. This works a lot like the range scan; see <code><a href="Scan.html#v:rangeOver">rangeOver</a></code> above for details
 on how the arguments work. However, the quick scan expects the following property to hold for its scan
 range: given two <em>a</em> values (i.e. values used to create the first CTD, P(a,1) in the Polydisk into Ball
 example), <em>a1</em> and <em>a2</em>, and given two corresponding <em>c</em> values, <em>c1</em> and <em>c2</em>, with the same offset from
 the largest <em>c</em> values of <em>a1</em> and <em>a2</em>, respectively (i.e. in the Polydisk into Ball example, 
 take c1 = 2+a1/2-e and c2 = 2+a2/2-e for some <em>e</em>), if there is no valid decomposition given by
 Theorem 1.19 for <em>a1</em> and <em>c1</em> and also no valid decomposition for <em>a2</em> and <em>c2</em>, then there is no
 valid decomposition for every <em>a</em> value between <em>a1</em> and <em>a2</em> using the corresponding <em>c</em> values with
 the same offset as before (i.e. for Polydisk into Ball, every <em>a</em> between <em>a1</em> and <em>a2</em> has no valid
 decomposition for c = 2+a/2-e, where <em>e</em> is the same as above). It can be shown that this property
 holds for the Polydisk into Ball problem. Using this property, quick scan will only fully scan two
 <em>(a,c)</em> pairs; for the rest, it will take its previous results and refine them by checking only that the
 action condition for generators being less than each other holds. This massively cuts down on computation
 time for computationally difficult scans.</p></div></div><h1 id="g:2">Modifying Output</h1><div class="top"><p class="src"><a name="v:useOffsets" class="def">useOffsets</a> ::  <a href="Scan.html#t:Scanner">Scanner</a> t1 t2 -&gt; <a href="Scan.html#t:Scanner">Scanner</a> t1 t2</p><div class="doc"><p>Takes a Scanner and returns the same Scanner, but set to use offsets. That is, the Scanner will
 output the arguments for the second CTD (in the above example, the c values that go into E(c,c)) as offsets
 from the maximum c value.</p></div></div><div class="top"><p class="src"><a name="v:noOffsets" class="def">noOffsets</a> ::  <a href="Scan.html#t:Scanner">Scanner</a> t1 t2 -&gt; <a href="Scan.html#t:Scanner">Scanner</a> t1 t2</p><div class="doc"><p>Takes a Scanner and returns the same Scanner, but set not to use offsets (see <code><a href="Scan.html#v:useOffsets">useOffsets</a></code> above).</p></div></div><div class="top"><p class="src"><a name="v:tabulate" class="def">tabulate</a> ::  <a href="Scan.html#t:Scanner">Scanner</a> t1 t2 -&gt; <a href="Scan.html#t:Scanner">Scanner</a> t1 t2</p><div class="doc"><p>Takes a Scanner and returns the same Scanner, but set to print its data to a table. The size
 of the table will be calculated based on the range of the Scanner when <code><a href="Scan.html#v:scan">scan</a></code> is called, and the
 column headings will default to &quot;CGen,&quot; &quot;a.&quot; &quot;c,&quot; and &quot;Result.&quot; See <code><a href="Scan.html#v:tabulateWith">tabulateWith</a></code> to change these
 defaults.</p></div></div><div class="top"><p class="src"><a name="v:tabulateWith" class="def">tabulateWith</a> ::  (String, String, String, String) -&gt; (Int, Int, Int) -&gt; <a href="Scan.html#t:Scanner">Scanner</a> t1 t2 -&gt; <a href="Scan.html#t:Scanner">Scanner</a> t1 t2</p><div class="doc"><p>Given a Scanner, returns the same Scanner, but set to print its data to a table. The first argument
 is a 4-tuple of the column headings to type; the second argument is a 3-tuple specifying the sizes
 of the first 3 columns.</p></div></div><div class="top"><p class="src"><a name="v:plainText" class="def">plainText</a> ::  <a href="Scan.html#t:Scanner">Scanner</a> t1 t2 -&gt; <a href="Scan.html#t:Scanner">Scanner</a> t1 t2</p><div class="doc"><p>Given a Scanner, returns the same Scanner set to print its data plainly. Each result will be printed
 on its own line; CGens and parameters of the CTDs will be comma-separated, and the results of Theorem 1.19
 will follow a colon.</p></div></div><div class="top"><p class="src"><a name="v:toStd" class="def">toStd</a> ::  <a href="Scan.html#t:Scanner">Scanner</a> t1 t2 -&gt; <a href="Scan.html#t:Scanner">Scanner</a> t1 t2</p><div class="doc"><p>Sets the given Scanner to print its data to StdOut (i.e. the terminal/command line).</p></div></div><div class="top"><p class="src"><a name="v:toFile" class="def">toFile</a> ::  String -&gt; Bool -&gt; <a href="Scan.html#t:Scanner">Scanner</a> t1 t2 -&gt; <a href="Scan.html#t:Scanner">Scanner</a> t1 t2</p><div class="doc"><p>Sets the given Scanner to print its data to a file. The first argument is a file name, and the
 second determines whether the file should be overwritten or appended to.</p></div></div><div class="top"><p class="src"><a name="v:toFileAndStd" class="def">toFileAndStd</a> ::  String -&gt; Bool -&gt; <a href="Scan.html#t:Scanner">Scanner</a> t1 t2 -&gt; <a href="Scan.html#t:Scanner">Scanner</a> t1 t2</p><div class="doc"><p>Sets the given Scanner to print its data to both a file and StdOut (i.e. the terminal/command line).
 The first argument is a file name, and the second determines whether the file should be overwritten 
 or appended to.</p></div></div><h1 id="g:3">Scanning</h1><div class="top"><p class="src"><a name="v:scan" class="def">scan</a> :: (RealFrac t1, Read t1, Show t1, RealFrac t2, Read t2, Show t2) =&gt; <a href="Scan.html#t:Scanner">Scanner</a> t1 t2 -&gt; IO ()</p><div class="doc"><p>Given a Scanner, runs the scan given by the range of the Scanner and outputs its results in accordance
 with the output settings of the Scanner.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.14.3</p></div></body></html>